# Maintainer: Your Name <you@example.com>

pkgname=container-use
_pkgname=container-use
pkgver=0.4.2
pkgrel=1
pkgdesc="Sandboxed dev environments for coding agents (Dagger-powered), with git worktree workflows"
arch=('x86_64' 'aarch64')
url="https://container-use.com"
license=('Apache-2.0')

depends=('glibc')
makedepends=('go')
optdepends=(
  'git: enable Git-based Container Use workflows'
  'docker: container runtime for environments'
  'podman: alternative container runtime'
)

provides=("${_pkgname}")
conflicts=("${_pkgname}-git" "${_pkgname}-bin")

# Use a signed git tag to pin the exact source without relying on JS-gated “assets/checksums”.
# This is deterministic (tag pin) and avoids the worse practice of SKIP on an HTTP tarball.
source=(
  "${pkgname}::git+https://github.com/dagger/container-use.git#tag=v${pkgver}"
)
sha256sums=('d4692a5187fe25fe7e7484eeb6bf98582e85904419cd9f0271ec31dd6b52bd34')

_prepare_go_env() {
  # Keep module downloads inside the build dir (avoid polluting ~/go)
  export GOPATH="${srcdir}/.gopath"
  export GOCACHE="${srcdir}/.gocache"
  export GOMODCACHE="${srcdir}/.gomodcache"
}

prepare() {
  cd "${srcdir}/${pkgname}"
  _prepare_go_env

  # Keep caches writable; reduces cleanup permission weirdness
  go mod download -modcacherw
  go mod verify
}

build() {
  cd "${srcdir}/${pkgname}"
  _prepare_go_env

  # Pass makepkg's flags into CGO toolchain (when CGO is in play)
  export CGO_CPPFLAGS="${CPPFLAGS}"
  export CGO_CFLAGS="${CFLAGS}"
  export CGO_CXXFLAGS="${CXXFLAGS}"
  export CGO_LDFLAGS="${LDFLAGS}"
  export CGO_ENABLED=1

  # Repro-ish builds: avoid VCS stamping surprises
  export GOFLAGS="-trimpath -mod=readonly -modcacherw -buildvcs=false"

  mkdir -p build

  local ldflags
  ldflags="-compressdwarf=false"
  
  # Only force external linking if we actually have LDFLAGS to pass through.
  if [[ -n "${LDFLAGS}" ]]; then
    ldflags="${ldflags} -linkmode=external -extldflags '${LDFLAGS}'"
  fi

  go build \
    -buildmode=pie \
    -ldflags "${ldflags}" \
    -o "build/" \
    ./cmd/...
}

package() {
  cd "${srcdir}/${pkgname}"

  # install -Dm755 "build/${_pkgname}" "${pkgdir}/usr/bin/${_pkgname}"
  # install -Dm755 "build/*" -t "${pkgdir}/usr/bin/"
  # install -d "$pkgdir/usr/bin"
  ls -al build/
  for bin in build/*; do 
    install -Dm755 "$bin" -t "$pkgdir/usr/bin/" 
  done

  # Docs and release notes use both `container-use ...` and `cu ...` styles; ship a friendly alias.
  ln -s "${_pkgname}" "${pkgdir}/usr/bin/cu"

  # install -Dm644 LICENSE "${pkgdir}/usr/share/licenses/${_pkgname}/LICENSE"
  install -Dm644 LICENSE* "${pkgdir}/usr/share/licenses/${_pkgname}/LICENSE"
  install -Dm644 README* -t "${pkgdir}/usr/share/doc/${_pkgname}/"
}
