# Maintainer: <you>
pkgname=dagger-git
_pkgname=dagger
pkgver=0.19.11.1.g16caa9a
pkgrel=1
pkgdesc="An open-source runtime for composable workflows (development version)"
arch=('x86_64' 'aarch64')
url="https://dagger.io"
license=('Apache-2.0')

depends=('glibc')
makedepends=('go')
options=('!lto' '!debug')

# Dagger runs an engine as a container; you need a container runtime available.
optdepends=(
  'git: enable Git-based Dagger workflows'
  'docker: container runtime used to run the Dagger Engine'
  'podman: alternative container runtime'
)

provides=("${_pkgname}")
conflicts=("${_pkgname}" "${_pkgname}-bin")

source=("${pkgname}::git+https://github.com/dagger/dagger.git")
sha256sums=('SKIP')

_git_describe() {
  cd "${srcdir}/${pkgname}"

  # Prefer engine/cli tags like v0.19.11*
  local d
  d="$(git describe --tags --abbrev=7 --match 'v[0-9]*' 2>/dev/null || true)"
  if [[ -n "${d}" ]]; then
    printf '%s\n' "${d}"
    return 0
  fi

  # Fallback: tags like sdk/go/v0.19.11* exist in the main repo
  d="$(git describe --tags --abbrev=7 --match 'sdk/go/v[0-9]*' 2>/dev/null || true)"
  if [[ -n "${d}" ]]; then
    printf '%s\n' "${d}"
    return 0
  fi

  # Last resort: “no tag in sight”
  printf 'devel-%s-g%s\n' "$(git rev-list --count HEAD)" "$(git rev-parse --short=7 HEAD)"
}

_version_from_git_describe() {
  # Convert:
  #   v0.19.11-1-gABCDEF0         -> v0.19.11-1-gABCDEF0
  #   sdk/go/v0.19.11-1-gABCDEF0  -> v0.19.11-1-gABCDEF0
  #   devel-123-gABCDEF0          -> devel-123-gABCDEF0
  local d="${1}"
  d="${d#sdk/go/}"
  printf '%s\n' "${d}"
}

_pkgver_from_version() {
  # Convert:
  #   v0.19.11-1-gABCDEF0  -> 0.19.11.1.gABCDEF0
  # (Arch pkgver can’t contain hyphens)
  local v="${1}"
  v="${v#v}"
  printf '%s\n' "${v}" | sed -E 's/-/./g'
}

pkgver() {
  local d v
  d="$(_git_describe)"
  v="$(_version_from_git_describe "${d}")"
  _pkgver_from_version "${v}"
}

_prepare_go_env() {
  # Keep module downloads inside the build dir (avoid polluting ~/go)
  export GOPATH="${srcdir}/.gopath"
  export GOCACHE="${srcdir}/.gocache"
  export GOMODCACHE="${srcdir}/.gomodcache"
}

prepare() {
  cd "${srcdir}/${pkgname}"
  _prepare_go_env

  # Keep caches writable; reduces cleanup permission weirdness
  go mod download -modcacherw
  go mod verify
}

build() {
  cd "${srcdir}/${pkgname}"
  _prepare_go_env

  # Pass makepkg's flags into CGO toolchain (when CGO is in play)
  export CGO_CPPFLAGS="${CPPFLAGS}"
  export CGO_CFLAGS="${CFLAGS}"
  export CGO_CXXFLAGS="${CXXFLAGS}"
  export CGO_LDFLAGS="${LDFLAGS}"
  export CGO_ENABLED=1

  # Repro-ish builds: avoid VCS stamping surprises
  export GOFLAGS="-trimpath -mod=readonly -modcacherw -buildvcs=false"

  mkdir -p build

  local d engine_ver engine_tag ldflags
  d="$(_git_describe)"
  engine_ver="$(_version_from_git_describe "${d}")"

  # Prefer a clean tag for Tag (no -N-gSHA), but fall back to engine_ver
  engine_tag="$(printf '%s\n' "${engine_ver}" | sed -E 's/^([^ ]*v[0-9]+\.[0-9]+\.[0-9]+).*/\1/')"
  if [[ -z "${engine_tag}" ]]; then
    engine_tag="${engine_ver}"
  fi

  ldflags="-compressdwarf=false -X github.com/dagger/dagger/engine.Version=${engine_ver} -X github.com/dagger/dagger/engine.Tag=${engine_tag}"

  # Only force external linking if we actually have LDFLAGS to pass through.
  if [[ -n "${LDFLAGS}" ]]; then
    ldflags="${ldflags} -linkmode=external -extldflags '${LDFLAGS}'"
  fi

  go build \
    -buildmode=pie \
    -ldflags "${ldflags}" \
    -o "build/" \
    ./cmd/...
}

package() {
  cd "${srcdir}/${pkgname}"

  # install -Dm755 "build/${_pkgname}" "${pkgdir}/usr/bin/${_pkgname}"
  # install -Dm755 "build/*" -t "${pkgdir}/usr/bin/"
  # install -d "$pkgdir/usr/bin"
  ls -al build/
  for bin in build/*; do 
    install -Dm755 "$bin" -t "$pkgdir/usr/bin/" 
  done

  install -Dm644 LICENSE* "${pkgdir}/usr/share/licenses/${_pkgname}/LICENSE"
  install -Dm644 README* -t "${pkgdir}/usr/share/doc/${_pkgname}/"
}
