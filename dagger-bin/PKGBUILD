# Maintainer: <you>
pkgname=dagger-bin
_pkgname=dagger
pkgver=0.19.10
pkgrel=1
pkgdesc="An open-source runtime for composable workflows (prebuilt binary)"
arch=('x86_64' 'aarch64' 'armv7h')
url="https://dagger.io"
license=('Apache-2.0')

depends=('glibc')
options=('!lto' '!debug')

# Dagger runs an engine as a container; you need a container runtime available.
optdepends=(
  'git: enable Git-based Dagger workflows'
  'docker: container runtime used to run the Dagger Engine'
  'podman: alternative container runtime'
)

provides=("${_pkgname}")
conflicts=("${_pkgname}" "${_pkgname}-git")

# Daggerâ€™s docs install via dl.dagger.io (with DAGGER_VERSION), and the distro includes checksums.
# The archive naming here follows the common GoReleaser-style pattern:
#   dagger_vX.Y.Z_linux_{amd64|arm64}.tar.gz
# If upstream changes naming, you only need to adjust _archive below.
source=(
  "${_pkgname}_v${pkgver}_checksums.txt::https://github.com/dagger/${_pkgname}/releases/download/v${pkgver}/checksums.txt"
)
source_x86_64+=(
  "${_pkgname}_v${pkgver}_linux_amd64.tar.gz::https://github.com/dagger/${_pkgname}/releases/download/v${pkgver}/${_pkgname}_v${pkgver}_linux_amd64.tar.gz"
)
source_aarch64+=(
  "${_pkgname}_v${pkgver}_linux_arm64.tar.gz::https://github.com/dagger/${_pkgname}/releases/download/v${pkgver}/${_pkgname}_v${pkgver}_linux_arm64.tar.gz"
)
source_armv7h+=(
  "${_pkgname}_v${pkgver}_linux_armv7.tar.gz::https://github.com/dagger/${_pkgname}/releases/download/v${pkgver}/${_pkgname}_v${pkgver}_linux_armv7.tar.gz"
)

# We verify the binary tarball ourselves via checksums.txt in prepare().
sha256sums=('de2b7f47e3dad8513b4f4a039b6026f9f0e8f7aeeae780d6fa1802d65b518a87')
sha256sums_x86_64=('3c9dfb11e8df8a21133843789a9dc9c9477176e45ebf00442a38bcf9cba4920a')
sha256sums_aarch64=('2e505f6d1c5985a00d6c6a3a126761c4bfb5ba128186565921ac402520bad8c6')
sha256sums_armv7h=('750c44787b995fe6cbbf799af45fa4c46fe4e65c5978ee7ea01d5ffde3946e30')

prepare() {
  cd "${srcdir}"

  local _tar=""
  case "${CARCH}" in
    x86_64)  _tar="${_pkgname}_v${pkgver}_linux_amd64.tar.gz" ;;
    aarch64) _tar="${_pkgname}_v${pkgver}_linux_arm64.tar.gz" ;;
    armv7h)  _tar="${_pkgname}_v${pkgver}_linux_armv7.tar.gz" ;;
    *) echo "Unsupported arch: $CARCH" >&2; exit 1 ;;
  esac

  # Verify ONLY the tarball we actually downloaded.
  grep -F "${_tar}" "${_pkgname}_v${pkgver}_checksums.txt" | sha256sum -c -
}

package() {
  cd "${srcdir}"

  local _tar=""
  case "${CARCH}" in
    x86_64)  _tar="${_pkgname}_v${pkgver}_linux_amd64.tar.gz" ;;
    aarch64) _tar="${_pkgname}_v${pkgver}_linux_arm64.tar.gz" ;;
    armv7h)  _tar="${_pkgname}_v${pkgver}_linux_armv7.tar.gz" ;;
    *) echo "Unsupported arch: $CARCH" >&2; exit 1 ;;
  esac

  mkdir -p "${pkgname}"
  bsdtar -xf "${_tar}" -C "${pkgname}"

  # The archive layout can vary (goreleaser often nests). Find an executable we can install.
  local _bin=""
  _bin="$(find "${pkgname}" -maxdepth 3 -type f -perm -111 -name "${_pkgname}" -print -quit)"

  if [[ -z "${_bin}" ]]; then
    printf 'ERROR: could not find %s or cu executable in release archive\n' "${_pkgname}" >&2
    return 1
  fi

  install -Dm755 "${_bin}" "${pkgdir}/usr/bin/${_pkgname}"

  # Friendly alias: /usr/bin/cu -> container-use
  # ln -s "${_pkgname}" "${pkgdir}/usr/bin/cu"

  # Install license if it exists in the archive (common with goreleaser)
  local _license=""
  _license="$(find "${pkgname}" -maxdepth 3 -type f -iname 'LICENSE*' -print -quit)"
  if [[ -n "${_license}" ]]; then
    install -Dm644 "${_license}" "${pkgdir}/usr/share/licenses/${_pkgname}/LICENSE"
  fi

  # Install docs if it exists in the archive (common with goreleaser)
  local _docs=""
  _docs="$(find "${pkgname}" -maxdepth 3 -type f -iname 'README*' -print -quit)"
  if [[ -n "${_docs}" ]]; then
    install -Dm644 "${_docs}" -t "${pkgdir}/usr/share/doc/${_pkgname}/"
  fi

  # Install shell manpage if they exist in the archive
  local _manpage_dir="${pkgname}/man"
  if [[ -d "${_manpage_dir}" ]]; then
    # Install manpage if it exists in the archive (common with goreleaser)
    local _manpage=""
    _manpage="$(find "${_manpage_dir}" -maxdepth 3 -type f -iname "${_pkgname}.1*" -print -quit)"
    if [[ -n "${_manpage}" ]]; then
      install -Dm644 "${_manpage}" -t "${pkgdir}/usr/share/man/man1/"
    fi
  fi
  
  # Install shell completions if they exist in the archive
  local _completions_dir="${pkgname}/completions"
  if [[ -d "${_completions_dir}" ]]; then
    local _file _basename _name _ext

    for _file in "${_completions_dir}"/*; do
      [[ -f "${_file}" ]] || continue
      _basename="$(basename "${_file}")"
      _name="${_basename%.*}"
      _ext="${_basename##*.}"

      case "${_ext}" in
        bash)
          install -Dm644 "${_file}" "${pkgdir}/usr/share/bash-completion/completions/${_name}"
          ;;
        fish)
          install -Dm644 "${_file}" "${pkgdir}/usr/share/fish/vendor_completions.d/${_basename}"
          ;;
        zsh)
          install -Dm644 "${_file}" "${pkgdir}/usr/share/zsh/site-functions/_${_name}"
          ;;
        *)
          msg2 "Skipping unknown completion file: ${_basename}"
          ;;
      esac
    done
  fi

}
