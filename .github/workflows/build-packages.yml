name: Build All Packages & Update Repository

on:
  # Manual trigger with package selection
  workflow_dispatch:
    inputs:
      packages:
        description: 'Package names to build (space-separated, or "all")'
        required: false
        default: 'all'
        type: string
      force_rebuild:
        description: 'Force rebuild even if no changes detected'
        required: false
        default: false
        type: boolean

  # Auto-trigger on package changes
  push:
    paths:
      - './**'
      - '.github/workflows/**'

  # Weekly full rebuild
  schedule:
    - cron: '0 2 * * 1'  # Every Monday at 2 AM UTC

env:
  REPO_NAME: "randall-aur"
  REPO_MAINTAINER: "Randall <me@randall.network>"

jobs:
  # Detect changed packages with fixed logic and robust output formatting
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.changes.outputs.packages }}
      matrix: ${{ steps.changes.outputs.matrix }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        fetch-depth: 2  # Need previous commit for comparison

    - name: Detect package changes
      id: changes
      run: |
        set -euo pipefail  # Fail fast on any error

        # Debug: Show current directory and available packages
        echo "=== DEBUG: Current directory contents ==="
        ls -la
        echo ""
        echo "=== DEBUG: Available PKGBUILD directories ==="
        find . -name "PKGBUILD" -exec dirname {} \; | sed 's|^\./||' | sort
        echo ""

        # Initialize packages array for robust processing
        declare -a PACKAGE_LIST=()

        # Logic fix: Properly check event types and inputs
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual trigger - check inputs
          if [ "${{ github.event.inputs.packages }}" = "all" ] || [ -z "${{ github.event.inputs.packages }}" ]; then
            echo "Manual trigger: building all packages"
            # Get all PKGBUILD directories reliably
            while IFS= read -r pkg; do
              if [ -n "$pkg" ]; then
                PACKAGE_LIST+=("$pkg")
              fi
            done < <(find . -name "PKGBUILD" -exec dirname {} \; | sed 's|^\./||' | sort)
          else
            echo "Manual trigger: building specified packages"
            # Parse space-separated package names correctly
            IFS=' ' read -ra PACKAGE_ARRAY <<< "${{ github.event.inputs.packages }}"
            for pkg in "${PACKAGE_ARRAY[@]}"; do
              if [ -n "$pkg" ]; then
                PACKAGE_LIST+=("$pkg")
              fi
            done
          fi

        elif [ "${{ github.event_name }}" = "schedule" ] || [ "${{ github.event.inputs.force_rebuild }}" = "true" ]; then
          echo "Scheduled or forced rebuild: building all packages"
          while IFS= read -r pkg; do
            if [ -n "$pkg" ]; then
              PACKAGE_LIST+=("$pkg")
            fi
          done < <(find . -name "PKGBUILD" -exec dirname {} \; | sed 's|^\./||' | sort)

        else
          # Push trigger - detect changes from git
          echo "Push trigger: detecting changes"
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep -E "^[^/]+/" || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No package changes detected"
          else
            echo "Changed files: $CHANGED_FILES"
            # Extract unique package directory names
            while IFS= read -r file; do
              if [ -n "$file" ]; then
                pkg_dir=$(echo "$file" | cut -d'/' -f1)
                # Check if this is a valid package directory and not already in list
                if [ -d "$pkg_dir" ] && [ -f "$pkg_dir/PKGBUILD" ]; then
                  # Avoid duplicates using associative array approach
                  already_added=false
                  for existing in "${PACKAGE_LIST[@]}"; do
                    if [ "$existing" = "$pkg_dir" ]; then
                      already_added=true
                      break
                    fi
                  done
                  if [ "$already_added" = false ]; then
                    PACKAGE_LIST+=("$pkg_dir")
                  fi
                fi
              fi
            done <<< "$CHANGED_FILES"
          fi
        fi

        # Debug: Show detected packages
        echo "=== DEBUG: Detected packages ==="
        printf '%s\n' "${PACKAGE_LIST[@]}" || echo "No packages detected"
        echo ""

        # Robust output generation using proper GitHub Actions patterns
        if [ ${#PACKAGE_LIST[@]} -gt 0 ]; then
          # Create space-separated packages string for legacy compatibility
          PACKAGES=$(printf '%s ' "${PACKAGE_LIST[@]}")
          PACKAGES="${PACKAGES% }"  # Remove trailing space

          echo "Final packages to build: $PACKAGES"

          # Create JSON matrix using jq with proper escaping and compact output
          # This approach is bulletproof for package names with special characters
          MATRIX_JSON=$(printf '%s\n' "${PACKAGE_LIST[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0)) | map({package: .})')

          echo "Matrix JSON: $MATRIX_JSON"

          # Use proper GitHub Actions output format with delimiter for safety
          {
            echo "packages=$PACKAGES"
            echo "matrix=$MATRIX_JSON"
          } >> "$GITHUB_OUTPUT"
        else
          echo "No packages to build"
          {
            echo "packages="
            echo "matrix=[]"
          } >> "$GITHUB_OUTPUT"
        fi

  # Build packages in parallel with fixed matrix consumption
  build-packages:
    needs: detect-changes
    if: needs.detect-changes.outputs.packages != ''
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.detect-changes.outputs.matrix) }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v5

    - name: Setup Arch Linux build environment
      env:
        # Optional: If you have specific GPG keys stored as secrets
        GPG_KEYRING: ${{ secrets.GPG_KEYRING }}  # Base64 encoded keyring file
        GPG_TRUST_DB: ${{ secrets.GPG_TRUST_DB }}  # Base64 encoded trustdb
      run: |
        # Update system and install build dependencies
        pacman -Syu --noconfirm
        pacman -S --noconfirm base-devel git curl gnupg pacman-contrib

        # Create build user (makepkg refuses to run as root)
        useradd -m -G wheel builder
        echo 'builder ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers

        # Setup build directory
        mkdir -p /home/builder/build
        chown -R builder:builder /home/builder/

        # Optional: Import pre-configured GPG keyring from secrets
        if [ -n "$GPG_KEYRING" ]; then
          echo "Importing pre-configured GPG keyring from secrets"
          echo "$GPG_KEYRING" | base64 -d > /home/builder/.gnupg/pubring.kbx
          chown -R builder:builder /home/builder/.gnupg/
          chmod 700 /home/builder/.gnupg/
          chmod 600 /home/builder/.gnupg/*
        fi

        # Configure GPG for better keyserver reliability
        sudo -u builder mkdir -p /home/builder/.gnupg
        cat > /home/builder/.gnupg/gpg.conf << 'EOF'
        # Keyserver configuration for reliability
        keyserver hkps://keyserver.ubuntu.com:443
        keyserver-options timeout=10
        keyserver-options import-clean
        keyserver-options no-honor-keyserver-url

        # Security settings
        personal-digest-preferences SHA512 SHA384 SHA256
        cert-digest-algo SHA512
        default-preference-list SHA512 SHA384 SHA256 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed

        # Display options
        keyid-format 0xlong
        with-fingerprint
        EOF

        cat > /home/builder/.gnupg/dirmngr.conf << 'EOF'
        # Keyserver configuration
        keyserver hkps://keyserver.ubuntu.com:443
        keyserver hkps://keys.openpgp.org

        # Connection settings
        timeout 10
        EOF

        chown -R builder:builder /home/builder/.gnupg/
        chmod 700 /home/builder/.gnupg/
        chmod 600 /home/builder/.gnupg/*

    - name: Import GPG keys for package
      run: |
        PACKAGE_DIR="/home/builder/build"
        cp -r ./${{ matrix.package }}/* "$PACKAGE_DIR/"
        chown -R builder:builder "$PACKAGE_DIR"

        cd "$PACKAGE_DIR"

        # Enhanced GPG key import with multiple fallback strategies
        if grep -q "validpgpkeys" PKGBUILD; then
          echo "=== Processing GPG keys for package: ${{ matrix.package }} ==="

          # Extract key fingerprints from validpgpkeys array - handle various formats
          KEYS=$(awk '/^validpgpkeys=/{
            # Handle single line format: validpgpkeys=('key1' 'key2')
            if (match($0, /validpgpkeys=\([^)]*\)/)) {
              line = substr($0, RSTART, RLENGTH)
              gsub(/validpgpkeys=\(|\)|'"'"'|"/, "", line)
              gsub(/[ \t]+/, " ", line)
              print line
              next
            }
          }
          /^validpgpkeys=\(/{
            # Handle multiline format
            gsub(/validpgpkeys=\(|\)|'"'"'|"/, "")
            print $0
            in_validpgpkeys=1
            next
          }
          in_validpgpkeys && /\)/{
            gsub(/\)|'"'"'|"/, "")
            print $0
            in_validpgpkeys=0
            next
          }
          in_validpgpkeys{
            gsub(/'"'"'|"/, "")
            print $0
          }' PKGBUILD | tr '\n' ' ' | xargs)

          if [ -n "$KEYS" ]; then
            echo "Found GPG keys to import: $KEYS"

            # Create array for reliable iteration
            IFS=' ' read -ra KEY_ARRAY <<< "$KEYS"

            for key in "${KEY_ARRAY[@]}"; do
              if [ -n "$key" ]; then
                echo "Processing GPG key: $key"

                # Multi-keyserver approach with proper error handling
                KEY_IMPORTED=false

                # Try modern keyservers with fallbacks
                for keyserver in "hkps://keyserver.ubuntu.com:443" "hkps://keys.openpgp.org" "hkp://keyserver.ubuntu.com:80"; do
                  echo "  Attempting to import from $keyserver"

                  if sudo -u builder timeout 30 gpg --keyserver "$keyserver" --recv-keys "$key" 2>/dev/null; then
                    echo "  ✓ Successfully imported key $key from $keyserver"
                    KEY_IMPORTED=true
                    break
                  else
                    echo "  ✗ Failed to import from $keyserver"
                  fi
                done

                # Alternative: Try to find key in common locations
                if [ "$KEY_IMPORTED" = false ]; then
                  echo "  Attempting alternative key sources for $key"

                  # Package-specific key handling for known packages
                  case "${{ matrix.package }}" in
                    "1password-cli-bin"|"1password-wayland")
                      echo "  Importing 1Password GPG key from official source"
                      if sudo -u builder curl -sSL "https://downloads.1password.com/linux/keys/1password.asc" | sudo -u builder gpg --import; then
                        KEY_IMPORTED=true
                      fi
                      ;;
                    "google-chrome-bin"|"google-chrome-canary-bin")
                      echo "  Importing Google Chrome GPG key from official source"
                      if sudo -u builder curl -sSL "https://dl.google.com/linux/linux_signing_key.pub" | sudo -u builder gpg --import; then
                        KEY_IMPORTED=true
                      fi
                      ;;
                    "microsoft-edge-stable-bin")
                      echo "  Importing Microsoft Edge GPG key from official source"
                      if sudo -u builder curl -sSL "https://packages.microsoft.com/keys/microsoft.asc" | sudo -u builder gpg --import; then
                        KEY_IMPORTED=true
                      fi
                      ;;
                    "visual-studio-code-bin")
                      echo "  Importing Visual Studio Code GPG key from official source"
                      if sudo -u builder curl -sSL "https://packages.microsoft.com/keys/microsoft.asc" | sudo -u builder gpg --import; then
                        KEY_IMPORTED=true
                      fi
                      ;;
                  esac
                fi

                if [ "$KEY_IMPORTED" = false ]; then
                  echo "  ⚠️  WARNING: Could not import GPG key $key from any source"
                  echo "  This may cause signature verification to fail"
                  # Don't exit here - let makepkg handle the verification failure
                else
                  echo "  ✓ GPG key $key successfully imported"
                fi
              fi
            done

            # Verify imported keys
            echo "=== GPG Key Status ==="
            sudo -u builder gpg --list-keys --keyid-format LONG | grep -A2 -B2 "$(echo $KEYS | tr ' ' '\|')" || true
          else
            echo "No GPG keys found in validpgpkeys array"
          fi
        else
          echo "No validpgpkeys found in PKGBUILD - skipping GPG key import"
        fi

    - name: Install AUR dependencies
      run: |
        cd /home/builder/build

        echo "=== Checking for AUR dependencies ==="

        # Extract all dependencies from PKGBUILD
        ALL_DEPS=$(grep -E "^(depends|makedepends|checkdepends)=" PKGBUILD | \
                   sed 's/.*=(//' | sed 's/).*//' | \
                   grep -oE "'[^']*'" | tr -d "'" | \
                   sort -u)

        if [ -n "$ALL_DEPS" ]; then
          echo "Found dependencies: $ALL_DEPS"

          AUR_DEPS=""
          OFFICIAL_DEPS=""

          # Categorize dependencies: AUR vs Official repos
          for dep in $ALL_DEPS; do
            # Clean dependency name (remove version constraints)
            clean_dep=$(echo "$dep" | sed 's/[<>=].*//')

            # Check if package exists in official repos
            if pacman -Si "$clean_dep" >/dev/null 2>&1; then
              OFFICIAL_DEPS="$OFFICIAL_DEPS $clean_dep"
              echo "  ✓ Official repo: $clean_dep"
            else
              # Check if it's a virtual package (provides)
              if pacman -Ss "^$clean_dep$" >/dev/null 2>&1; then
                OFFICIAL_DEPS="$OFFICIAL_DEPS $clean_dep"
                echo "  ✓ Official repo (virtual): $clean_dep"
              else
                AUR_DEPS="$AUR_DEPS $clean_dep"
                echo "  ? AUR candidate: $clean_dep"
              fi
            fi
          done

          # Install official dependencies first
          if [ -n "$OFFICIAL_DEPS" ]; then
            echo "Installing official dependencies..."
            pacman -S --noconfirm --needed $OFFICIAL_DEPS
          fi

          # Handle AUR dependencies
          if [ -n "$AUR_DEPS" ]; then
            echo "=== Processing AUR dependencies ==="

            # Create a temporary build directory for dependencies
            mkdir -p /tmp/aur-deps

            for aur_dep in $AUR_DEPS; do
              echo "Processing AUR dependency: $aur_dep"

              cd /tmp/aur-deps

              # Skip if already processed
              if [ -d "$aur_dep" ]; then
                echo "  Already processed: $aur_dep"
                continue
              fi

              # Try to clone from AUR
              if git clone "https://aur.archlinux.org/${aur_dep}.git" 2>/dev/null; then
                echo "  ✓ Found in AUR: $aur_dep"
                cd "$aur_dep"

                # Quick validation
                if [ -f PKGBUILD ]; then
                  echo "  Building AUR dependency: $aur_dep"

                  # Build without installing dependencies (assume they exist)
                  if sudo -u builder makepkg -sc --noconfirm; then
                    # Install as dependency
                    BUILT_PKG=$(ls *.pkg.tar.zst | head -1)
                    if [ -n "$BUILT_PKG" ]; then
                      pacman -U --noconfirm --asdeps "$BUILT_PKG"
                      echo "  ✓ Installed AUR dependency: $aur_dep"
                    fi
                  else
                    echo "  ⚠️  Failed to build AUR dependency: $aur_dep"
                    echo "  This may cause the main package build to fail"
                  fi
                else
                  echo "  ✗ Invalid AUR package: $aur_dep (no PKGBUILD)"
                fi
              else
                echo "  ✗ AUR package not found: $aur_dep"
                echo "  This dependency may need manual resolution"
              fi
            done

            cd /home/builder/build
          fi
        else
          echo "No dependencies found in PKGBUILD"
        fi

        # Show final dependency status
        echo "=== Final dependency check ==="
        if grep -E "^(depends|makedepends)=" PKGBUILD >/dev/null 2>&1; then
          echo "Checking if all dependencies are now available..."
          # This will be validated during the actual build step
        fi

    - name: Validate and build package
      run: |
        cd /home/builder/build

        echo "=== Building package: ${{ matrix.package }} ==="

        # Enhanced source verification with detailed error reporting
        echo "=== Verifying package sources ==="
        if ! sudo -u builder makepkg --verifysource; then
          echo "⚠️  Source verification failed - this may be due to network issues"
          echo "Checking available sources..."
          if [ -f PKGBUILD ]; then
            echo "Sources defined in PKGBUILD:"
            grep -E "^source" PKGBUILD || echo "No sources found"
          fi
        fi

        # Generate .SRCINFO for repository metadata
        echo "=== Generating .SRCINFO ==="
        sudo -u builder makepkg --printsrcinfo > .SRCINFO

        # Run namcap checks if available
        if command -v namcap >/dev/null 2>&1; then
          echo "=== Running namcap validation ==="
          namcap PKGBUILD || echo "namcap warnings (non-fatal)"
        fi

        # Build package with enhanced error handling
        echo "=== Building package ==="
        BUILD_SUCCESS=false
        BUILD_ATTEMPTS=0
        MAX_ATTEMPTS=2

        while [ $BUILD_ATTEMPTS -lt $MAX_ATTEMPTS ] && [ "$BUILD_SUCCESS" = false ]; do
          BUILD_ATTEMPTS=$((BUILD_ATTEMPTS + 1))
          echo "Build attempt $BUILD_ATTEMPTS of $MAX_ATTEMPTS"

          if sudo -u builder makepkg -sc --noconfirm; then
            BUILD_SUCCESS=true
            echo "✓ Package build successful"
          else
            BUILD_EXIT_CODE=$?
            echo "✗ Build attempt $BUILD_ATTEMPTS failed with exit code: $BUILD_EXIT_CODE"

            case $BUILD_EXIT_CODE in
              2)
                echo "❌ Build Error: Likely compilation or dependency issue"
                ;;
              6)
                echo "❌ GPG Verification Error: Could not verify package signatures"
                echo "Available GPG keys in keyring:"
                sudo -u builder gpg --list-keys --keyid-format LONG || echo "No keys found"

                if [ $BUILD_ATTEMPTS -lt $MAX_ATTEMPTS ]; then
                  echo "Retrying with --skippgpcheck for this build"
                  if sudo -u builder makepkg -sc --noconfirm --skippgpcheck; then
                    BUILD_SUCCESS=true
                    echo "⚠️  Package built with PGP verification skipped"
                    echo "WARNING: This reduces security - consider adding proper GPG keys"
                  fi
                fi
                ;;
              8)
                echo "❌ Integrity Check Error: Source file checksums don't match"
                echo "This usually indicates:"
                echo "  - Source files have been updated upstream"
                echo "  - Network corruption during download"
                echo "  - PKGBUILD needs checksum updates"
                ;;
              10)
                echo "❌ Missing Dependencies: Required packages not available"
                echo "Checking available packages..."
                # Could add logic to check for AUR dependencies here
                ;;
              *)
                echo "❌ Unknown build error (exit code: $BUILD_EXIT_CODE)"
                ;;
            esac

            if [ $BUILD_ATTEMPTS -lt $MAX_ATTEMPTS ]; then
              echo "Waiting 5 seconds before retry..."
              sleep 5
            fi
          fi
        done

        if [ "$BUILD_SUCCESS" = false ]; then
          echo "❌ Package build failed after $MAX_ATTEMPTS attempts"
          exit 1
        fi

        # Test installation
        echo "=== Testing package installation ==="
        PACKAGE_FILE=$(ls *.pkg.tar.zst | head -1)
        if [ -n "$PACKAGE_FILE" ]; then
          echo "Installing package: $PACKAGE_FILE"
          pacman -U --noconfirm "$PACKAGE_FILE"
          echo "✓ Package installed successfully"

          # Store package info for artifacts
          echo "PACKAGE_FILE=$PACKAGE_FILE" >> $GITHUB_ENV
          echo "PACKAGE_NAME=${{ matrix.package }}" >> $GITHUB_ENV
        else
          echo "❌ No package file found after build"
          exit 1
        fi

    - name: Upload package artifact
      uses: actions/upload-artifact@v4
      with:
        name: package-${{ matrix.package }}
        path: |
          /home/builder/build/*.pkg.tar.zst
          /home/builder/build/.SRCINFO
        retention-days: 30

  # Collect all packages and update repository
  update-repository:
    needs: [detect-changes, build-packages]
    if: needs.detect-changes.outputs.packages != '' && success()
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: gh-pages

    - name: Setup repository environment
      run: |
        # Install pacman for repo-add
        sudo apt-get update
        sudo apt-get install -y wget

        # Download and install pacman (for repo-add tool)
        wget -O pacman.tar.zst "https://archive.archlinux.org/packages/p/pacman/pacman-6.0.2-7-x86_64.pkg.tar.zst"
        sudo tar -xf pacman.tar.zst -C /

        # Create repository directories
        mkdir -p repo/x86_64
        mkdir -p packages

    - name: Download all built packages
      uses: actions/download-artifact@v5
      with:
        path: artifacts/
        pattern: package-*
        merge-multiple: false

    - name: Update repository database
      run: |
        cd repo/x86_64

        # Copy new packages
        find ../../artifacts/ -name "*.pkg.tar.zst" -exec cp {} . \;

        # Remove old packages (keep only latest version)
        echo "Cleaning old package versions..."
        for pkg in *.pkg.tar.zst; do
          PKGNAME=$(echo "$pkg" | sed 's/-[^-]*-[^-]*-[^-]*\.pkg\.tar\.zst$//')
          LATEST=$(ls ${PKGNAME}-*.pkg.tar.zst | sort -V | tail -1)
          for old in ${PKGNAME}-*.pkg.tar.zst; do
            if [ "$old" != "$LATEST" ]; then
              echo "Removing old package: $old"
              rm -f "$old" "${old}.sig"
            fi
          done
        done

        # Create/update repository database
        repo-add --verify --sign ${{ env.REPO_NAME }}.db.tar.xz *.pkg.tar.zst

        # Create index page
        cat > ../index.html << 'EOF'
        <!DOCTYPE html>
        <html>
        <head>
            <title>Custom AUR Repository</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                .package { margin: 20px 0; padding: 15px; border: 1px solid #ddd; }
                code { background: #f4f4f4; padding: 2px 6px; }
            </style>
        </head>
        <body>
            <h1>Custom AUR Repository</h1>
            <h2>Installation</h2>
            <p>Add to your <code>/etc/pacman.conf</code>:</p>
            <pre>
        [custom-aur]
        SigLevel = Optional TrustAll
        Server = https://yourusername.github.io/repo-name/repo/$arch
            </pre>
            <p>Then run: <code>sudo pacman -Sy</code></p>

            <h2>Available Packages</h2>
        EOF

        # List packages
        for pkg in *.pkg.tar.zst; do
          echo "<div class='package'><strong>$pkg</strong></div>" >> ../index.html
        done

        echo "</body></html>" >> ../index.html

        echo "Repository updated with $(ls *.pkg.tar.zst | wc -l) packages"

    - name: Commit and push repository updates
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git add .
        git commit -m "Update repository: $(date)" || echo "No changes to commit"
        git push origin gh-pages

    - name: Setup GitHub Pages
      uses: actions/configure-pages@v5

    - name: Deploy to GitHub Pages
      uses: actions/deploy-pages@v4
      with:
        artifact_name: github-pages
