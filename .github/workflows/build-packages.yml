name: Build All Packages & Update Repository

on:
  # Manual trigger with package selection
  workflow_dispatch:
    inputs:
      packages:
        description: 'Package names to build (space-separated, or "all")'
        required: false
        default: 'all'
        type: string
      force_rebuild:
        description: 'Force rebuild even if no changes detected'
        required: false
        default: false
        type: boolean

  # Auto-trigger on package changes
  push:
    paths:
      - './**'
      - '.github/workflows/**'

  # Weekly full rebuild
  schedule:
    - cron: '0 2 * * 1'  # Every Monday at 2 AM UTC

env:
  REPO_NAME: "randall-aur"
  REPO_MAINTAINER: "Randall <me@randall.network>"

jobs:
  # Detect changed packages with fixed logic and robust output formatting
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.changes.outputs.packages }}
      matrix: ${{ steps.changes.outputs.matrix }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        fetch-depth: 2  # Need previous commit for comparison

    - name: Detect package changes
      id: changes
      run: |
        set -euo pipefail  # Fail fast on any error

        # Debug: Show current directory and available packages
        echo "=== DEBUG: Current directory contents ==="
        ls -la
        echo ""
        echo "=== DEBUG: Available PKGBUILD directories ==="
        find . -name "PKGBUILD" -exec dirname {} \; | sed 's|^\./||' | sort
        echo ""

        # Initialize packages array for robust processing
        declare -a PACKAGE_LIST=()

        # Logic fix: Properly check event types and inputs
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # Manual trigger - check inputs
          if [ "${{ github.event.inputs.packages }}" = "all" ] || [ -z "${{ github.event.inputs.packages }}" ]; then
            echo "Manual trigger: building all packages"
            # Get all PKGBUILD directories reliably
            while IFS= read -r pkg; do
              if [ -n "$pkg" ]; then
                PACKAGE_LIST+=("$pkg")
              fi
            done < <(find . -name "PKGBUILD" -exec dirname {} \; | sed 's|^\./||' | sort)
          else
            echo "Manual trigger: building specified packages"
            # Parse space-separated package names correctly
            IFS=' ' read -ra PACKAGE_ARRAY <<< "${{ github.event.inputs.packages }}"
            for pkg in "${PACKAGE_ARRAY[@]}"; do
              if [ -n "$pkg" ]; then
                PACKAGE_LIST+=("$pkg")
              fi
            done
          fi

        elif [ "${{ github.event_name }}" = "schedule" ] || [ "${{ github.event.inputs.force_rebuild }}" = "true" ]; then
          echo "Scheduled or forced rebuild: building all packages"
          while IFS= read -r pkg; do
            if [ -n "$pkg" ]; then
              PACKAGE_LIST+=("$pkg")
            fi
          done < <(find . -name "PKGBUILD" -exec dirname {} \; | sed 's|^\./||' | sort)

        else
          # Push trigger - detect changes from git
          echo "Push trigger: detecting changes"
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep -E "^[^/]+/" || true)

          if [ -z "$CHANGED_FILES" ]; then
            echo "No package changes detected"
          else
            echo "Changed files: $CHANGED_FILES"
            # Extract unique package directory names
            while IFS= read -r file; do
              if [ -n "$file" ]; then
                pkg_dir=$(echo "$file" | cut -d'/' -f1)
                # Check if this is a valid package directory and not already in list
                if [ -d "$pkg_dir" ] && [ -f "$pkg_dir/PKGBUILD" ]; then
                  # Avoid duplicates using associative array approach
                  already_added=false
                  for existing in "${PACKAGE_LIST[@]}"; do
                    if [ "$existing" = "$pkg_dir" ]; then
                      already_added=true
                      break
                    fi
                  done
                  if [ "$already_added" = false ]; then
                    PACKAGE_LIST+=("$pkg_dir")
                  fi
                fi
              fi
            done <<< "$CHANGED_FILES"
          fi
        fi

        # Debug: Show detected packages
        echo "=== DEBUG: Detected packages ==="
        printf '%s\n' "${PACKAGE_LIST[@]}" || echo "No packages detected"
        echo ""

        # Robust output generation using proper GitHub Actions patterns
        if [ ${#PACKAGE_LIST[@]} -gt 0 ]; then
          # Create space-separated packages string for legacy compatibility
          PACKAGES=$(printf '%s ' "${PACKAGE_LIST[@]}")
          PACKAGES="${PACKAGES% }"  # Remove trailing space

          echo "Final packages to build: $PACKAGES"

          # Create JSON matrix using jq with proper escaping and compact output
          # This approach is bulletproof for package names with special characters
          MATRIX_JSON=$(printf '%s\n' "${PACKAGE_LIST[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0)) | map({package: .})')

          echo "Matrix JSON: $MATRIX_JSON"

          # Use proper GitHub Actions output format with delimiter for safety
          {
            echo "packages=$PACKAGES"
            echo "matrix=$MATRIX_JSON"
          } >> "$GITHUB_OUTPUT"
        else
          echo "No packages to build"
          {
            echo "packages="
            echo "matrix=[]"
          } >> "$GITHUB_OUTPUT"
        fi

  # Build packages in parallel with fixed matrix consumption
  build-packages:
    needs: detect-changes
    if: needs.detect-changes.outputs.packages != ''
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.detect-changes.outputs.matrix) }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v5

    - name: Setup Arch Linux build environment
      run: |
        # Update system and install build dependencies
        pacman -Syu --noconfirm
        pacman -S --noconfirm base-devel git curl gnupg pacman-contrib

        # Create build user (makepkg refuses to run as root)
        useradd -m -G wheel builder
        echo 'builder ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers

        # Setup build directory
        mkdir -p /home/builder/build
        chown -R builder:builder /home/builder/

    - name: Import GPG keys for package
      run: |
        PACKAGE_DIR="/home/builder/build"
        cp -r ./${{ matrix.package }}/* "$PACKAGE_DIR/"
        chown -R builder:builder "$PACKAGE_DIR"

        cd "$PACKAGE_DIR"

        # Extract GPG keys from PKGBUILD if present
        if grep -q "validpgpkeys" PKGBUILD; then
          KEYS=$(grep "validpgpkeys" PKGBUILD | sed "s/.*=(['\"]\\([^'\"]*\\)['\"].*/\\1/")
          for key in $KEYS; do
            echo "Importing GPG key: $key"
            sudo -u builder gpg --keyserver keyserver.ubuntu.com --recv-keys "$key" || \
            sudo -u builder curl -sS "https://downloads.1password.com/linux/keys/1password.asc" | sudo -u builder gpg --import || \
            echo "Could not import key $key - continuing anyway"
          done
        fi

    - name: Install AUR dependencies
      run: |
        cd /home/builder/build

        # Check for AUR dependencies in depends/makedepends
        AUR_DEPS=$(grep -E "^(depends|makedepends)=" PKGBUILD | \
                   grep -oE "'[^']*'" | tr -d "'" | \
                   while read dep; do
                     if ! pacman -Si "$dep" >/dev/null 2>&1; then
                       echo "$dep"
                     fi
                   done | tr '\n' ' ')

        if [ -n "$AUR_DEPS" ]; then
          echo "Installing AUR dependencies: $AUR_DEPS"
          for dep in $AUR_DEPS; do
            echo "Installing $dep from AUR"
            sudo -u builder git clone "https://aur.archlinux.org/${dep}.git" "/tmp/$dep"
            cd "/tmp/$dep"
            sudo -u builder makepkg -si --noconfirm --asdeps
            cd /home/builder/build
          done
        fi

    - name: Validate and build package
      run: |
        cd /home/builder/build

        echo "=== Building package: ${{ matrix.package }} ==="

        # Verify sources are accessible
        sudo -u builder makepkg --verifysource

        # Generate .SRCINFO
        sudo -u builder makepkg --printsrcinfo > .SRCINFO

        # Run namcap checks
        if command -v namcap >/dev/null 2>&1; then
          namcap PKGBUILD || echo "namcap warnings (non-fatal)"
        fi

        # Build package
        sudo -u builder makepkg -sc --noconfirm

        # Test installation
        PACKAGE_FILE=$(ls *.pkg.tar.zst)
        pacman -U --noconfirm "$PACKAGE_FILE"

        echo "Successfully built: $PACKAGE_FILE"

        # Store package info
        echo "PACKAGE_FILE=$PACKAGE_FILE" >> $GITHUB_ENV
        echo "PACKAGE_NAME=${{ matrix.package }}" >> $GITHUB_ENV

    - name: Upload package artifact
      uses: actions/upload-artifact@v4
      with:
        name: package-${{ matrix.package }}
        path: |
          /home/builder/build/*.pkg.tar.zst
          /home/builder/build/.SRCINFO
        retention-days: 30

  # Collect all packages and update repository
  update-repository:
    needs: [detect-changes, build-packages]
    if: needs.detect-changes.outputs.packages != '' && success()
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        ref: gh-pages

    - name: Setup repository environment
      run: |
        # Install pacman for repo-add
        sudo apt-get update
        sudo apt-get install -y wget

        # Download and install pacman (for repo-add tool)
        wget -O pacman.tar.zst "https://archive.archlinux.org/packages/p/pacman/pacman-6.0.2-7-x86_64.pkg.tar.zst"
        sudo tar -xf pacman.tar.zst -C /

        # Create repository directories
        mkdir -p repo/x86_64
        mkdir -p packages

    - name: Download all built packages
      uses: actions/download-artifact@v5
      with:
        path: artifacts/
        pattern: package-*
        merge-multiple: false

    - name: Update repository database
      run: |
        cd repo/x86_64

        # Copy new packages
        find ../../artifacts/ -name "*.pkg.tar.zst" -exec cp {} . \;

        # Remove old packages (keep only latest version)
        echo "Cleaning old package versions..."
        for pkg in *.pkg.tar.zst; do
          PKGNAME=$(echo "$pkg" | sed 's/-[^-]*-[^-]*-[^-]*\.pkg\.tar\.zst$//')
          LATEST=$(ls ${PKGNAME}-*.pkg.tar.zst | sort -V | tail -1)
          for old in ${PKGNAME}-*.pkg.tar.zst; do
            if [ "$old" != "$LATEST" ]; then
              echo "Removing old package: $old"
              rm -f "$old" "${old}.sig"
            fi
          done
        done

        # Create/update repository database
        repo-add --verify --sign ${{ env.REPO_NAME }}.db.tar.xz *.pkg.tar.zst

        # Create index page
        cat > ../index.html << 'EOF'
        <!DOCTYPE html>
        <html>
        <head>
            <title>Custom AUR Repository</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 40px; }
                .package { margin: 20px 0; padding: 15px; border: 1px solid #ddd; }
                code { background: #f4f4f4; padding: 2px 6px; }
            </style>
        </head>
        <body>
            <h1>Custom AUR Repository</h1>
            <h2>Installation</h2>
            <p>Add to your <code>/etc/pacman.conf</code>:</p>
            <pre>
        [custom-aur]
        SigLevel = Optional TrustAll
        Server = https://yourusername.github.io/repo-name/repo/$arch
            </pre>
            <p>Then run: <code>sudo pacman -Sy</code></p>

            <h2>Available Packages</h2>
        EOF

        # List packages
        for pkg in *.pkg.tar.zst; do
          echo "<div class='package'><strong>$pkg</strong></div>" >> ../index.html
        done

        echo "</body></html>" >> ../index.html

        echo "Repository updated with $(ls *.pkg.tar.zst | wc -l) packages"

    - name: Commit and push repository updates
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
        git add .
        git commit -m "Update repository: $(date)" || echo "No changes to commit"
        git push origin gh-pages

    - name: Setup GitHub Pages
      uses: actions/configure-pages@v5

    - name: Deploy to GitHub Pages
      uses: actions/deploy-pages@v4
      with:
        artifact_name: github-pages
